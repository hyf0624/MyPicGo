# 一丶注册小程序

使用浏览器打开`https://mp.weixin.qq.com/`网址，点击右上角的"**立即注册**"即可进入到小程序开发账号的注册流程，主要流程截图如下：847377855@qq.com

![image-20230301102221722](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230301102221722.png)

![image-20230301102246359](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230301102246359.png)

紧跟着输入表单信息即可注册完成！

注册小程序获取AppId：

![image-20230301103112052](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230301103112052.png)



下一步安装开发者工具：`https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html`



# 二丶创建小程序

![image-20230330142501329](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230330142501329.png)



**1.了解项目的基本组成结构**

- **pages用来存放所有小程序的页面**
- utils用来存放工具性质的模块(例如：格式化时间定义的模块)
- **app.js 小程序项目入口文件**
- **app.json小程序项目的全局配置文件**
- app.wxss 小程序项目的全局样式文件
- project.config.json 项目的配置文件
- sitemap.json 用来配置小程序及其页面是否允许被微信索引

**2.小程序的页面组成部分**

​	官方建议把所有小程序页面都存放在`pages`目录中，以单独的文件夹存在，如图所示：

![1677651587135](C:\Users\hyf\Documents\WeChat Files\wxid_yqgmr6glm75322\FileStorage\Temp\1677651587135.png)

其中，每个页面**由4个基本文件**组成, 它们分别是：

- **.js**文件 （页面的脚本文件，存放页面的数据、事件处理函数等）
- **.json**文件 （当前页面的配置文件，配置窗口的外观、表现等）
- **.wxml**文件 （页面的模板结构文件）
- **.wxss**文件 （当前页面的样式文件）



**3.Json配置文件的作用**

 JSON是一种数据格式,在实际开发中，JSON总是以**配置文件**的形式出现的。小程序项目中也不例外：通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。

  小程序项目中有4种json配置文件，分别是：	

- 项目根目录中的$\textcolor{RedOrange}{app.json} $配置文件

- 项目根目录中的$\textcolor{RedOrange}{project.config.json} $配置文件

- 项目根目录中的sitemap.json 配置文件

- $\textcolor{RedOrange}{每个文件夹中的.json配置文件} $

  ​			

**4.app.json文件**

 app.json是当前小程序的**全局配置**，包括小程序的所有页面路径、窗口外观、界面表现、底部tab等。

Demo项目里边的app.json配置内容如下：

````js
{
  // pages：用来记录当前小程序所有页面的路径
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  
  // window: 全局定义小程序所有页面的背景颜色、文字颜色等。
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
      
  // 全局定义小程序所有组件使用样式版本(全新的样式)
  "style": "v2",
      
   // 用来指明sitemap.json的位置
  "sitemapLocation": "sitemap.json"
}

````



**5.project.config.json文件**

project.config.json是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：

- **setting中保存了编译相关的配置**
- **projectname 中保存的是项目名称**
- **appid中保存的是小程序的账号ID**



**6.sitemap.json文件**

微信现已开发**小程序内搜索**，效果类似于PC网页的SEO，sitemap.json文件用来**配置小程序页面是否允许微信索引**。

当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。

```javascript
{
  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",
  "rules": [{
  "action": "allow",
  "page": "*"
  }]
}
```



**7.页面的.json配置文件**

小程序中的每个页面，可以使用.json文件夹对页面的窗口外观进行配置，**页面中的配置项会覆盖掉app.json的window中相同的配置项**

```js
// app.json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}

// index.json
{
  "usingComponents": {},
  "navigationBarBackgroundColor": "#00B26A" // 会覆盖掉app.json 中相同的配置
}
```



# 三丶如何新建小程序页面

### 1.新增页面

只需在**app.json**  -> **pages**中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件，

如图所示：

![image-20230301155451946](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230301155451946.png)



### **2.如何修改项目的首页：**

只需要调整app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页. 小程序会把排在第一位的页面，当作项目的首页进行渲染，如图所示：

![image-20230301161119743](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230301161119743.png)



### 3.小程序中的WXML是什么

WXML(WeiXin Markup Language) 是小程序框架设计的一套**标签语言，用来构建小程序页面的结构**其作用类似于网页开发中的HTML。

### 4.WXML和HML的区别

1.  **标签名称不同**	
   - HTML (div, span , img , a)
   - WXML (view, text, image, navigator)
2. **属性节点不同**
   - `<a href="#">超链接</a>`
   - `<navigator url="/pages/home/home"></navigator>`
3. **提供类似于Vue中的模板语法**
   -  数据绑定
   - 列表渲染
   - 条件渲染



### 5.什么是WXSS，WXSS和CSS的区别

1. **新增了rpx尺寸单位**
   - css中需要手动进行像素单位换算，例如rem
   - wxss在底层支持的尺寸单位rpx, 在不同大小的屏幕上程序会自动进行换算
2. **提供了全局样式和局部样式**
   - 项目根目录中的app.wxss会作用于所有小程序页面
   - 局部页面的 .wxss样式仅对当前页面生效
3. **WXSS仅支持部分的CSS选择器**
   - .class和#id
   - element 
   - 并集选择器、后代选择器
   - ::after 和 ::before 等伪类选择器



### 6.小程序中的.js文件

分为三大类：

- app.js
  - **是整个小程序项目的入口文件，通过调用App() 函数来启动整个小程序**
- 页面的.js文件
  - **是页面的入口文件，通调用Page()函数来创建并运行页面**	
- 普通的.js文件
  - **是普通的功能模块文件，用来封装公共的函数或属性供页面使用。**







### 7.宿主环境简介

什么是宿主环境：

宿主环境(host environment) 指的是**程序运行所必须的依赖环境**。例如：

**Android系统**和**IOS系统**是两个不同的宿主环境。安卓版的微信App是不能在IOS环境下运行，所以，

Android是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的。

**小程序的宿主环境:**

**手机微信就是小程序的宿主环境**



### 8.小程序宿主环境包含的内容

1. 通信模型
2. 运行机制
3. 组件
4. API

通信的主体：

​	小程序中通信的主体是**渲染层**和**逻辑层**，其中：	

- WXML模板和WXSS样式是工作在渲染层的
- JS脚本是工作在逻辑层的

小程序的通信模型：

​	分为两部分

		1. **渲染层**和**逻辑层**的通信由微信客户端进行转发
		1. **逻辑层**和**第三方服务器**之间的通信由微信客户端进行转发



# 四丶小程序的运行机制

1.小程序启动过程

- 把小程序的代码包下载到本地
- 解析app.json全局配置文件
- 执行app.js小程序入口文件，**调用App() 创建小程序**
- 渲染小程序的首页
- 启动完成

2.页面渲染过程

- 加载解析页面的.json配置文件
- 加载页面的.wxml模板和.wxss样式
- 执行页面的.js文件，**调用Page（）创建页面实例**
- 页面渲染完成



# 五丶小程序中的组件

1.小程序中组件的分类

​	**小程序中的组件也是由宿主环境提供的**,官方把小程序的组件分为9大类：

- **视图容器**
- **基础内容**
- **表单组件**
- **导航组件**
- 媒体组件
- map地图组件
- canvas画布组件
- 开放能力
- 无障碍访问

2.常用的视图容器类组件

- **view**

  - 普通的视图区域组件
  - 类似于HTMl中的div，一个块级元素
  - 常用来实现页面的布局效果

  ![image-20230302090027241](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230302090027241.png)

  ```js
  // .wxml
  <view class="container1">
    <view>A</view>
    <view>B</view>
    <view>C</view>
  </view>
  
  // .wxss
  /* pages/list/list.wxss */
  .container1 {
    display: flex;
    justify-content: space-around;
  }
  .container1 view {
    width: 100px;
    height: 100px;
    text-align: center;
    line-height: 100px;
  }
  .container1 view:nth-child(1){
    background-color: lightgreen;
  }
  .container1 view:nth-child(2){
    background-color: lightskyblue;
  }
  .container1 view:nth-child(3){
    background-color: lightpink;
  }
  ```

  

- **scroll-view**

  - 可滚动的视图区域
  - 常用来实现滚动列表效果

  ![image-20230302090628511](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230302090628511.png)

  ````js
  // .wxml
  <scroll-view class="container1" scroll-y>
    <view>A</view>
    <view>B</view>
    <view>C</view>
  </scroll-view>
  
  // 需要给container1固定宽高即可实现滚动效果
  .container1 {
    border: 1px solid #000;
    width: 100px;
    height: 120px;
  }
  ````

  

- **swiper和swiper-item**

  - 轮播容器组件和轮播图item组件

````js
<swiper class="swiper-container" autoplay circular indicator-dots indicator-active-color="gray" indicator-color="white">
  <swiper-item>
    <view class="item">A</view>
  </swiper-item>
  <swiper-item>
    <view class="item">B</view>
  </swiper-item>
  <swiper-item>
    <view class="item">C</view>
  </swiper-item>
</swiper>

// 
.swiper-container {
  height: 150px;
}

.item {
  height: 100%;
  line-height: 150px;
  text-align: center;
}
swiper-item:nth-child(1){
  background-color: lightgreen;
}
swiper-item:nth-child(2){
  background-color: lightpink;
}
swiper-item:nth-child(3){
  background-color: lightskyblue;
}
````



- **text组件的用法**
  - 文本组件
  - 类似于HTML中的span标签，是一个行内元素

```js
<!--pages/list/list.wxml-->
<view>
  长按复制手机号: <text user-select>1212121212121212121</text>
</view>
```

- **rich-text组件**
  - 富文本组件
  - 支持把HTML字符串渲染为WXML结构		

```js
<rich-text nodes="<h1 style='color: red'>标题</h1>"></rich-text>
```

![image-20230302104853476](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230302104853476.png)



**其他常用组件**

- button

````js

<!-- 通过type属性指定按钮的颜色 -->
<button>普通按钮</button>
<button type="primary">主色调按钮</button>
<button type="warn">警告按钮</button>
<!-- size="mini" 小尺寸按钮 -->
<button size="mini">普通按钮</button>
<button type="primary" size="mini">主色调按钮</button>
<button type="warn" size="mini">警告按钮</button>
<!-- plain 镂空按钮 -->
<button size="mini" plain>普通按钮</button>
<button type="primary" size="mini" plain>主色调按钮</button>
<button type="warn" size="mini" plain>警告按钮</button>
````

- image
- navigator

**官方文档: https://developers.weixin.qq.com/miniprogram/dev/component/**



# 六丶小程序API

分为了三大类：

- 事件监听API

  - 特点： 以`on`开头，用来监听某些事件的触发

    举例：**wx.onWindowResize(function callback)**监听窗口尺寸变化的事件

- 同步API

  - 特点1：以`Sync`结尾的API都是同步API
  - 特点2：同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
  - 举例：**wx.setStorageSync('key', 'value')**向本地存储中写入内容

- 异步API

  - 特点：类似于jQuery中的**$.ajax(option)**函数，需要通过success、fail、complete接收调用的结果
  - 举例：**wx.request()**	发起网络数据请求，通过success回调函数接收数据



# 七丶 小程序中的数据绑定:

在wxml文件中的数据绑定和vue类似，但是也有区别:

```js
// 在模板里使用数据
<view>{{ info }}</view>
// 三元运算的方式
<view>{{flag ? '' :'' }}</view>
// 这里的属性绑定和vue还是有区别的
<image src="{{imageUrl}}"></image>

// 在js文件里定义数据
// 获取应用实例
const app = getApp()
Page({
    data: {
        info: 'hello world',
        flag: true,
        imageUrl: 'www.baidu.img.sec'
    }
})
```



### 1.**小程序中常用的事件**

|  类型  |         绑定方式          |                  事件描述                   |
| :----: | :-----------------------: | :-----------------------------------------: |
|  tap   |    bindtap或者bind:tap    | 手指触摸后马上离开，类似于HTML中的click事件 |
| input  |  bindinput或者bind:input  |              文本框的输入事件               |
| change | bindchange或者bind:change |               状态改变时触发                |

**事件对象的属性列表**

当事件回调触发的时候，会收到一个事件对象event，它的详细属性如下所示

```js
// .wxml
<button type="primary" size="mini" bindtap="buttonBindTap">主色调按钮</button>

// .js
// pages/list/list.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
	
  },
  // 定义按钮的事件处理函数
  buttonBindTap(e){
    console.log(e)
  },
})
```

**通过事件修改data中的值**: 利用`setData`方法

```js
Page({

  /**
   * 页面的初始数据
   */
  data: {
	count: 1
  },
  // 定义按钮的事件处理函数
  buttonBindTap(e){
    console.log(e)
    this.setData({
        count: this.data.count + 1 
    })
  },
})
```

### **事件传参**:

`<button bindtap='btnHandler(123)'>事件传参</button>`

**上面这种写法是错误的，小程序会误以为`btnHandler(123)`是事件的名称**

正确的写法：

可以为组件提供`data-*`自定义属性参数, 其中 `*代表的是参数的名字`, 事例代码如下：

```js
<button bindtap='btnHandler' data-info="{{2}}">事件传参</button>
```

最终：

- `info`会被解析为`参数的名字`
- 数值`2`会被解析为参数的值



**事件函数中如何接收传入的参数?**

可以通过`event.targer.dataset.参数名`即可获取到具体的参数值，示例代码如下：

```js
btnHandler(event){
    console.log(e)
    console.log(e.target.dataset)
    console.log(e.target.dataset.info)
}
```

![image-20230303100724918](C:\Users\hyf\AppData\Roaming\Typora\typora-user-images\image-20230303100724918.png)

**需要注意的是event中的target和currentTarget的区别: **

```js
<view id="outer" class="outer" bindtap="onClickTap" data-money="2000">
 <view id="inner" class="inner"></view>
</view>
```

如上代码事件时绑定在父元素身上的，如果点击是内部元素的话

**通过控制台输出结果发现target指向inner。currentTarget指向outer。结合事件传播机制原理分析:默认冒泡情况，捕获失效，首先，事件从外层盒子依次往内层传递，寻找目标源，一直找到inner盒子，发现inner盒子就是目标源，事件池内部没有存放inner盒子的事件，那么无法调用inner盒子的事件回调处理函数，所以inner盒子不是currentTarget。事件往外层开始传递，传递到outer盒子，如果outer盒子绑定的事件和触发时候的事件类型一致，那么触发事件回调处理函数，此时outer盒子就是currentTarget**

原文链接：https://blog.csdn.net/weixin_43364458/article/details/129341956

### **2.bindinput的语法格式**

```js
// .wxml
<input bindinput="inputHandler" class="inputs"></input>

// .js
 inputHandler(event){
    // event.detail.value是变化过后，文本框最新的值
    console.log(event.detail.value)
  },
```



### 3.文本框和data中的数据同步

````js
// .wxml 
// 这里input框绑定初始值
<input value="{{msg}}" bindinput="inputHandler" class="inputs"></input>


// .js
inputHandler: debounce(function(event){
    // event.detail.value是变化过后，文本框最新的值
    console.log(event.detail.value)
    this.setData({
      msg: event.detail.value
    })
  }, 500),
````



### 4.条件渲染

- **wx:if**

  在框架中，使用 `wx:if=""` 来判断是否需要渲染该代码块：

```js
<view wx:if="{{condition}}"> True </view>
```

也可以用 `wx:elif` 和 `wx:else` 来添加一个 else 块：

```js
<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>
```

- **block wx:if**

因为 `wx:if` 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```js
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

**注意：** `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性

- `wx:if` vs `hidden`

因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是**惰性的**，如果在初始渲染条件为 `false`，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。



### 5.列表渲染

通过wx:for可以根据指定的数组，循环渲染重复的组件结构，语法如下

```js
<view wx:for="{{array}}">
	索引是: {{index}}当前项是: {{item}}
</view>
```

**默认情况下,当前循环的索引用index表示，当前循环项用item表示**

```js
Page({
  data: {
    array: [{
      message: 'foo',
    }, {
      message: 'bar'
    }]
  }
})
```

使用 `wx:for-item` 可以指定数组当前元素的变量名，

使用 `wx:for-index` 可以指定数组当前下标的变量名：

```js
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>
```

**wx:key**

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[switch](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。

当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

**如不提供 `wx:key`，会报一个 `warning`， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略**



# 八丶配置tabBar

### **tabBar节点的配置项**

|      属性       |   类型    |  必填  | 默认值 |                   描述                    |
| :-------------: | :-------: | :----: | :----: | :---------------------------------------: |
|    position     |  String   |   否   | bottom |    tabBar的位置，仅支持 `bottom / top`    |
|   borderStyle   |  String   |   否   | black  | tabBar上边框的颜色，仅支持`black / white` |
|      color      | HexColor  |   否   |        |       tab上文字的默认（未选中）颜色       |
|  selectedColor  | HexColor  |   否   |        |          tab上的文字选中时的颜色          |
| backgroundColor | HexColor  |   否   |        |             tabBar的背景颜色              |
|    **list**     | **Array** | **是** |        |    tab页签的列表**,最少2个，最多5个**     |

### **每个tab项的配置选项**

|       属性       |  类型  | 必填 |                         描述                          |
| :--------------: | :----: | :--: | :---------------------------------------------------: |
|   **pagePath**   | String |  是  |        **页面路径，页面必须在pages中预先定义**        |
|     **text**     | String |  是  |                  **tab上显示的文字**                  |
|     iconPath     | String |  否  | **未选中时**的图标路径；当position为top时，不显示icon |
| selectedIconPath | String |  否  |  **选中时**的图标路径；当position为top时，不显示icon  |

**app.json**

````js
{
  "pages": [
    "pages/list/list",
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window": {
    "backgroundTextStyle": "dark",
    "navigationBarBackgroundColor": "#2b4b6b",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle": "black",
    "enablePullDownRefresh": true,
    "backgroundColor": "#efefef",
    "onReachBottomDistance": 50
  },
  "tabBar": {
    "list": [
      {
        "pagePath": "pages/list/list",
        "text": "list"
      },
      {
        "pagePath": "pages/index/index",
        "text": "index"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
````



### 页面配置中常用的配置项

|             属性             |   类型   | 默认值  |                      描述                       |
| :--------------------------: | :------: | :-----: | :---------------------------------------------: |
| navigationBarBackgroundColor | HexColor | #000000 |         当前页面导航栏背景颜色,如#00000         |
|    navigationBarTextStyle    |  String  |  white  | 当前页面导航栏标题颜色，仅支持 `black / white`  |
|    navigationBarTitleText    |  String  |         |           当前页面导航栏标题文字内容            |
|       backgroundColor        | HexColor | #ffffff |             当前页面窗口的背景颜色              |
|     backgroundTextStyle      |  String  |  dark   | 当前页面下拉loading的样式，仅支持`dark / light` |
|  **enablePullDownRefresh**   | Boolean  |  false  |        是否为当前页面开启下拉刷新的效果         |
|    onReachBottomDistance     |  Number  |   50    |  页面上拉触底事件触发距页面底部距离，单位为px   |



# 九丶配置request合法域名

假设在自己的微信小程序中，希望请求 `https://www.escook.cn`域名下的接口，

配置步骤： **登录微信小程序管理后台  --> 开发 --> 开发设置 --> 服务器域名 --> 修改request合法域名**

注意事项：

- 域名只支持https协议
- 域名不能使用IP地址或者localhost
- 域名必须经过ICP备案
- 服务器域名一个月内最多可申请5次修改



### 1.发起GET请求

调用微信小程序提供的`wx.request()`方法, 可以发起GET请求数据，示例代码如下：

```js
wx.request({
	url: 'https://www.escook.cn/api/get', // 请求的接口地址，必须基于https协议
	method:'GET', // 请求方式
	data: {
		name: 'hyf',
		age: 24
	},
	success: (res) => { // 请求成功之后的回调函数
		console.log(res)
	}
})
```

### 2.发起POST请求

调用微信小程序提供的wx.request()方法，可以发起POST请求，示例代码如下：

````js
wx.request({
	url:'https://www.escook.cn/api/post'
	method:'POST',
	data:{
		name:'ls',
		gender:'男'
	},
	success: (res) => {
		console.log(res)
	}
})
````



# **十丶页面导航**

### 1.声明式导航

**导航到tabBar页面**

**tabBar**页面指的是被配置为tabBar的页面。

在使用`<navigator>`组件跳转到指定的tabBar页面时，需要指定`url`属性和`open-type`属性，

- url表示跳转的**页面的地址**必须以`/`开头
- open-type表示**跳转的方式**必须以`switchTab`

```js
<navigator url="/pages/message/message" open-type="switchTab">导航到消息页面</navigator>
```



**导航到非tabBar页面**.

非tabBar页面指的是没有被配置为tabBar的页面。

在使用`<navigator>`组件跳转到普通的非tabBar页面时，则需要指定url属性和open-type属性，其中：

- url表示要跳转的**页面地址**,必须以`/`开头
- open-type表示跳转的方式，必须为`navigate`

```js
<navigator url="/pages/info/info" open-type="navigate">导航到info</navigator>
```



### 2.后退导航

如果要后退到上一页或多级页面，则需要指定open-type属性和delta属性，其中：

- open-type的值必须是`navigateBack`，表示进行后退导航
- delta值必须是数字，表示要后退的层级

示例代码如下：

```js
<navigator open-type="navigateBack" delta="1">返回上一页</navigator>
```

注意：为了简便，如果是后退到上一页，则可以省略delta属性，因为其默认值就是 `1`



### 3.编程式导航

**导航到tabBar页面**

调用`wx.switchTab(Object Object)`方法，可以跳转到tabBar页面。其中Object参数对象的属性列表如下：

|   属性   |   类型   | 是否必选 |                      说明                      |
| :------: | :------: | :------: | :--------------------------------------------: |
|   url    |  string  |    是    |  需要跳转单的tabBar页面路径，路径后不能带参数  |
| success  | function |    否    |             接口调用成功的回调函数             |
|   fail   | function |    否    |             接口调用失败的回调函数             |
| complete | function |    否    | 接口调用结束的回调函数(调用成功、失败都会执行) |

示例代码:

```js
// 页面结构
<button bindtap="gotoMessage">跳转到消息页面</button>

// 通过编程式导航，跳转到message页面
gotoMessage(){
 wx.switchTab({
 	url:'/pages/message/message'
 })
}
```

**后退导航**:

调用`wx.navigateBack(Object Object)`方法，可以返回上一级或者多级页面，其中Object参数对象的属性列表如下：

|   属性   |   类型   | 是否必选 |                        说明                         |
| :------: | :------: | :------: | :-------------------------------------------------: |
|   url    |  string  |    是    | 返回的页面数，如果delta大于现有的页面数，则返回首页 |
| success  | function |    否    |               接口调用成功的回调函数                |
|   fail   | function |    否    |               接口调用失败的回调函数                |
| complete | function |    否    |   接口调用结束的回调函数(调用成功、失败都会执行)    |

示例代码：

```js
// 页面结构
<button bindtap="gotoBack">回退</button>

// 编程式导航，后退到上一页面
gotoBack(){
  wx.navigateBack()
}
```



### 4.导航传参

navigator组件的url属性用来指定将要跳转的页面的路径，同时，**路径的后面可以携带参数：**

- 参数与路径之前使用`?`分隔
- 参数键与参数值用`=`相连
- 不同参数用`&`分隔

示例代码：

```js
<navigator url="/pages/info/info?name=zs&age=20">跳转到info页面</navigator>
```



**编程式导航传参**

调用`wx.navigateTo(Object)`方法跳转页面时，也可以携带参数，代码示例如下：

```js
// 页面结构
<button bindtap="gotInfo2">跳转到info页面</button>

// 通过编程式导航，携带参数
gotoInfo2(){
 wx.navigateTo({
   url: '/pages/info/info?name=ls&gender=男'
 })
}
```

**在onload中接收导航参数**

通过**声明式导航传参**或**编程式导航传参**所携带的参数，可以直接在onload事件中直接获取到

```js
/*
 生命周期函数 -- 监听页面加载
*/
onLoad: function(options){
  // options 就是导航传递过来的参数对象
  console.log(options)
}
```

# 十一丶页面事件

### 1.下拉刷新

**下拉刷新**是移动端的专有名词，指的是手指在屏幕上的下拉滑动操作，从而**重新加载页面数据**的行为

启用下拉刷新的两种方式：

1. 全局下拉刷新
   - 在app.json 的window节点中，将enablePullDownRefresh设置为true (不推荐)
2. 局部下拉刷新
   - 在页面的 .json 配置文件中，将enablePullDownRefresh设置为true 

​	

3.配置下拉刷新窗口的样式

在全局或页面的.json配置文件中，通过`backgroundColor`和`backgroundTextStyle`来配置下拉刷新窗口的样式。其中：

- `backgrundColor`  用来配置下拉刷新 `窗口的背景颜色`, 仅支持16进账的颜色值
- `backgroundTextStyle`用来配置下拉刷新loading的样式，仅支持dark和light

4.监听页面的下拉刷新事件

在页面的.js文件中，通过`onPullDownRefresh()`函数即可监听当前页面的下拉刷新事件。

5.停止下拉刷新`wx.stopPullDownRefresh()`

### 6.什么是上拉触底

**上拉触底**是移动端转有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多的数据。通过`onReachBottomDistance`属性来配置上拉触底的距离，默认是50px

**监听上拉触底**

```js
	 /**
     * 页面上拉触底事件的处理函数
     */
  onReachBottom() {
	this.getColors()
  },
  getColors() {
    // 展示loading效果
    wx.showLoading({
      title: '数据加载中...',
    })
    wx.request({
      url: 'https://www.escook.cn/api/color',
      method: 'GET',
      success: (({
        data: res
      }) => {
        if (res.message === 'success') {
          this.setData({
            colorList: [...this.data.colorList, ...res.data]
          })
        }
      }),
      complete: () => {
        wx.hideLoading() // 隐藏loading效果 
      }
    })
  },    
```

**上拉触底进行节流处理**

- 在data中定义isLoading 节流阀
  - false表示当前没有进行任何数据请求
  - true表示当前正在进行数据请求
- 在getColor()方法中修改isLoading节流阀的值
  - 在刚调用getColors时将节流阀设置为true
  - 在网络请求的complete回调函数中，将节流阀重置为false
- 在onReachBottom中判断节流阀的值，从而对数据请求进行节流控制
  - 如果节流阀的值为true, 则阻止当前请求
  - 如果节流阀的值为false，则发起数据请求



# 十二丶生命周期

**1.应用生命周期**：

- 特指小程序从启动 --> 运行 --> 销毁的过程

**2.页面生命周期:**

- 特指小程序中，每个页面的加载 -->渲染 --> 销毁的过程

### 3.应用生命周期函数

小程序的应用生命周期函数需要在app.js中进行声明，代码如下：

```js
// app.js
App({
  // 小程序初始化完成时，执行此函数，全局只触发一次。可以做一些初始化的工作。
   onLaunch(options){
      
   },
   // 小程序启动，或从后台进入前台显示时触发 
   onShow(){
       
   },
   // 小程序从前台进入后台时触发
   onHide(){
       
   }
})
```

### 4.页面的生命周期函数

小程序的页面生命周期需要在页面的 .js 文件中进行声明

```js
// 页面的 .js文件
Page({
 onLoad(){options}, // 监听页面加载，一个页面只调用1次
 onShow(){}, // 监听页面显示
 onReady(){}, // 监听页面初次渲染完成，一个页面只调用1次
 onHide(){}, // 监听页面隐藏
 onUnload(){} // 监听页面卸载，一个页面只调用1次
})
```



### 5.内嵌wxs 脚本

wxs代码可以编写在wxml文件中的`<wxs>`标签内，就像javascript代码可以编写在html文件中的scrip标签里一样

wxml文件中的每个`<wxs></wxs>`标签，**必须提供module属性**用来指定当前wxs模块名称，方便在wxml中访问模块中的成员：

```js
<view>{{ m1.toUpper('username')}}</view>
<wxs module="m1">
  module.exports.toUpper = function (str) {
    return str.toUpperCase()
  }
</wxs>
```

### 6.外联的wxs脚本

在wxml中引入外联的wxs脚本时，必须为`<wxs>`标签添加`module`和`src`属性，其中：

- module用来指定模块的名称
- src用来指定要引入的脚本的路径，且必须是相对路径

示例代码如下：

```js
// 调用 m2 模块中的方法
<view>{{ m2.toLower(country) }}</view>

// 引用外联的 tools.wxs 脚本， 并命名为 m2
<wxs src="./../../utils/tools.wxs"></wxs>
```



# 十三丶自定义组件

### 1.局部引用组件

在页面的 .json配置文件中引用组件的方式，叫做 "**局部引用**" 示例代码:

```js
// 在页面的 .json文件中，引入组件
{
    "usingComponents": {
      "my-test1": "/components/test/test"
    }
}

// 在页面的 .wxml 文件中，使用组件
<my-test1></my-test1>
```



### 2.**全局引用组件**

在app.json 全局配置文件中引入组件的方式，叫做“**全局引用**”。示例代码：

```js
// 在 app.json 文件中，引入组件
{
  "pages": [],
  "window": [],
  "usingComponents": {
      "my-test1": "/components/test/test"
   }
}

// 在页面的 .wxml 文件中，使用组件
<my-test1></my-test1>
```



### 3.组件和页面的区别

从表面来看,组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成。但是，组件和页面的.js 与 .json文件有明显的区别:

- 组件的.json文件中需要声明`"component":true`属性
- 组件的.js文件中调用的是`Component( )` 函数
- 组件的事件处理函数需要定义到`methods`节点中



### 4.组件样式

组件之间的样式是相互隔离的, 好处：

- 防止外界的样式影响组件内部的样式
- 防止组件的样式破坏外界的样式



### 5.组件样式需要注意的点

- app.wxss中的全局样式对组件无效
- 只有class选择器会有样式隔离效果，id选择器、属性选择器、标签选择器不受样式隔离的影响

建议： 在组件和引用组件的页面中建议使用class 选择器。不要使用id 、属性、标签选择器。



### 6.修改组件的样式隔离选项

默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过`styleIsolation`修改组件的样式隔离选项，用法如下：

```js
// 在组件的.js文件中新增如下配置
Component({
  options: {
    styleIsolation: 'isolated'
  }
})

// 或在组件的 .json文件中新增如下配置
{
 "styleIsolation": "isolated"
}
```

请参考官方文档： https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB

### 7.组件中的data数据和methods方法

```js
// components/test/test.js
Component({
  options: {
    styleIsolation: "apply-shared"
  },

  /**
   * 组件的属性列表
   */
  properties: {
    myProperty: {
      type: String,
      value: 'hello'
    }
  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {
     
  }
})
```

### 8.自定义组件的properties

properties和vue的props很相似

```js
// components/test/test.js
Component({
  options: {
    styleIsolation: "apply-shared"
  },

  /**
   * 组件的属性列表
   */
  properties: {
    // 定义接收的参数
    myProperty: {
      type: String,	 // 类型
      value: 'hello' // 默认值
    }
  },
})

// 给组件test传入myProperty
<my-test1 myProperty="hello World"></my-test1>
```



### 9.data和properties的去区别

在小程序组件中，properties属性和data数据的用法是相同的，它们都是**可读可写的**只不过：

- data更倾向于**存储组件的私有数据**
- properties更倾向于**存储外界传递到组件内部的数据**

需要注意的是，组件中的`data`和`properties`指向的是同一个对象

```js
 methods: {
    showInfo(){
      console.log(this.data.myProperty)
      console.log(this.properties)
      console.log(this.data === this.properties)// true
    }
  }
```

### 10.可以使用setData修改 properties的值

这点和vue不同。vue中的props是只读的并不能直接对其修改，但是微信小程序中的properties是可以修改的

```js
// 在组件的 .wxml 文件中使用properties属性的值
<view>max属性的值为：{{ max }}</view>

Component({
 properties: {max: Number} // 定义属性
 methods: {
   addCount(){
     // 使用setData修改属性
     this.setData({
       max: this.properties.max + 1
     })
   }
 }
})
```



### 11.数据监听器

什么是数据监听器

数据监听器用于**监听和响应任何属性和数据字段的变化, 从而执行特点的操作**它的作用类似于

vue watch侦听器。在小程序的组件中，数据监听器的基本语法如下：

```js
Component({
  observers: {
    '字段A,字段B': function(字段A的新值, 字段B的新值){
      // do something
    }
  }
})
```

**监听对象的属性变化**

监听对象的多个 属性或者单个属性:

```js
Component({
 observers: {
  '对象.属性A, 对象.属性B': function(属性A的新值, 属性B的新值){
    // 触发此监听器的三种情况
    // 为属性A赋值，setData设置 this.data.对象.属性A 时触发
    // 为属性B赋值，setData设置 this.data.对象.属性B 时触发
    // 直接为对象赋值, setData设置 this.data.对象 时触发
  }
 }
})
```

如果某个对象中需要被监听的属性太多了，为了方便，可以使用`通配符 **`来监听对象中属性的变化，示例:

```js
observers: {
  //'rgb.r, rgb.g, rgb.b': function (r, g, b) {
   //   this.setData({
   //     fullColor: `${r},${g},${b}`
   //   })
  // },
  // 使用通配符 ** 监听对象上所有属性的变化
  'rgb.**': function(obj){
	 this.setData({
        fullColor: `${obj.r},${obj.g},${obj.b}`
     })  
  }
}
```



### 12.纯数据字段

**什么是纯数据字段?**

概念: 纯数据字段指的是那些不用于界面渲染的data字段。

应用场景：例如有些情况下,  某些data中的字段**既不会展示在界面上, 也不会传递给其他组件**，仅仅在当前组件内部使用。带有这种特性的data字段适合被设置为纯数据字段。

好处：纯数据字段**有助于提升页面更新的性能**



**如何定义纯数据字段？**

在Component构造器的options节点中，指定`pureDataPattern`为一个`正则表达式`,  字段名符合这个正则表达式的字段将成为纯数据字段，示例代码如下：

```js
Component({
 options: {
  //指定所有 _ 开头的数据字段为纯数据字段
  pureDataPattern: /^_/
 },
 data: {
  a:true, // 普通数据字段
  _b: true // 纯数据字段
 }
})
```



# 十四丶组件的生命周期

**1.组件全部的生命周期函数**

| 生命周期函数 |            参数             |                        描述说明                         |
| :----------: | :-------------------------: | :-----------------------------------------------------: |
| ==created==  | <font color='red'>无</font> |   <font color='red'>在组件实例刚刚被创建时执行</font>   |
| ==attached== | <font color='red'>无</font> | <font color='red'>在组件实例进入页面节点树时执行</font> |
|    ready     |             无              |              在组件在视图层布局完成后执行               |
|    moved     |             无              |        在组件实例被移动到节点树另一个位置时执行         |
| ==detached== |           ==无==            |         ==在组件实例被从页面节点树移除时执行==          |
|    error     |        Object Error         |               每当组件方法抛出错误时执行                |



2.**组件中**==主要的==生命周期函数

在小程序中，最重要的生命周期函数有3个, 分别是<font color='red'>created</font>、==attached==、<font color='red'>detached</font>, 它们的各自特点如下	

  组件实例<font color='red'>刚好被创建好</font>的时候，created生命周期函数会被触发

- 此时还不能调用 setData
- 通常这个生命周期函数中，只应用于给组件的this添加一些自定义的属性字段

 在组件<font color='red'>初始化完毕、进入页面节点树后</font>, attached生命周期函数会被触发

- 此时，this.data 已被初始化完毕
- 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行(例如发送网络请求获取数据)

 在组件<font color='red'>离开页面节点树后</font>, detached生命周期函数会被触发

- 退出一个页面时，会触发页面内每个自定义组件的detached生命周期函数
- 此时适合做一些清理性质的工作							

​		

3.==lifetimes==节点

 在小程序组件中，生命周期函数可以直接定义在Component构造器的第一季参数中，可以在<font color='red'>lifetimes</font>字段内进行声明(<font color='red'>这是推荐的方式，其优先级最高</font>)，示例代码如下：

```js
Component({
  // 推荐用法
  lifetimes: {
    attached(){},
    detached(){}
  },
  // 以下是旧式的定义方式(不推荐)
  attached(){},
  detached(){},
})
```



4.**组件页面所在的生命周期**

有时，<font color='red'>自定义组件的行为依赖于页面状态的变化</font>,此时就需要用到<font color='red'>组件所在页面的生命周期</font>.

| 生命周期函数 |    参数     |                        描述                         |
| :----------: | :---------: | :-------------------------------------------------: |
|     show     |     无      | <font color='red'>组件所在的页面被展示时执行</font> |
|     hide     |     无      | <font color='red'>组件所在的页面被隐藏时执行</font> |
|    resize    | Object Size | <font color='red'>组件所在页面尺寸变化时执行</font> |

```js
Component({
 pageLifetimes: {
   show: function(){
   
   },
   hide: function(){
   
   },
   resize: function(size){
   	
   }
 }
})
```



# 十五丶插槽

小程序中插槽的使用和vue中用法类似：

1.默认每个自定义组件只允许使用一个`slot`进行占位，这种个数上的限制叫做单个插槽

```js
<!-- 组件的封装者 -->
<view class="wrapper">
   <view>这里是组件的内部节点</view>
   <!-- 对于不确定的内容，可以使用<slot> 进行占位，具体内容由组件的使用者决定 -->
</view>

<!-- 组件的使用者 -->
<component-tag-name>
    <!-- 这部分内容将放置在组件<slot>的位置上 -->
    <view>这里的插入到组件slot中的内容</view>
</component-tag-name>
```

2.小程序的自定义组件中，需要使用多个`<slot>`插槽时，可以在组件的.js文件中进行配置

```js
Component({
  options:{
    multipleSlots: true // 开启配置多个插槽
  },
})
```

**3.定义多个插槽**

用法类似于vue中的具名插槽, 以不同的name来区分不同的插槽.



```js
// 组件定义
<view>
  <!-- 对于不确定的内容使用slot -->
  <slot name="before"></slot>
  <view>test4组件本身的节点</view>
  <slot name="after"></slot>
</view>

// 组件使用
<my-test4>
 <text slot="before">组件使用者插入组件slot中的内容</text>
</my-test4>
```



# 十六丶组件通信

### **1.父子组件之间通信的3种方式**

- 属性绑定

  ​	用于父组件向子组件的指定属性设置数据，仅能设置JSON兼容的数据

- 事件绑定

  ​	用于子组件向父组件传递数据，可以传递任意数据

- 获取组件实例

​			父组件还可以通过`this.selectComponent()`获取子组件实例对象

​			这样就可以直接访问子组件的任意数据和方法.

### 2.属性绑定(父传子)

代码如下：

```js
// 父组件
<my-test4 max="{{12}}"></my-test4>

// 子组件
Component({
 properties: {max: Number} // 定义属性
})
```



### 3.事件绑定(子传父)

<font color='red'>事件绑定</font>用于实现<font color='red'>子向父传值</font>，可以传递任何数据。步骤如下：

​	1.在<font color='red'>在父组件</font>的js中，定义一个函数，这个函数<font color='red'>即将</font>通过自定义事件的形式，传递给子组件

​    2.在<font color='red'>父组件</font>的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用，传递给子组件

​	3.在<font color='cornflowerblue'>子组件</font>的js中，通过调用<font color='red'>this.triggerEvent('自定义事件名称','参数对象')</font>将数据发送到父组件

​    4.在<font color='red'>父组件</font>的js中，通过<font color='red'>e.detail</font>获取到子组件传递过来的数据

```js
// 在父组件中绑定自定义事件

// 使用 bind: 自定义事件名称 (推荐：结构清晰)
<my-test count="{{count}}" bind:sync="syncCount"></my-test>
// 或在bind后直接写自定义事件名称
<my-test count="{{count}}" bindsync="syncCount"></my-test>

Page({
    syncCount(e){
      console.log(e.detail) // 子组件发送过来的数据
   }   	
})
 
// 子组件内部
Cmponent({
  methods: {
   addCount(){
      this.setData({
		count: this.properties.count + 1	
      }) 
      this.triggerEvent('sync', {value: this.properties.count})
   }
 }
})
```



### 4.获取组件实例对象

可在父组件里调用`this.selectComponent('id或class选择器')`, 获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个<font color='red'>选择器</font>,例如this.selectComponent(".my-component")

```js
// 父组件 js文件
getChildCompoment(){
      const component = this.selectComponent('#my-test4')
      console.log(component)
      // 可以直接调用component身上的方法和 setData
      component.addCount() 
},
    
// 子组件 js文件
Component({
  options: {
    multipleSlots: true // 开启配置多个插槽
  },
  /**
   * 组件的属性列表
   */
  properties: {
    country: String
  },

  /**
   * 组件的初始数据
   */
  data: {
    count: 1
  },

  /**
   * 组件的方法列表
   */
  methods: {
    postEmit(){
      this.triggerEvent('countryLow',this.properties.country.toLowerCase())
    },
    addCount(){
      this.setData({
        count: this.data.count + 1
      })
    }
  }
})    
```



### 5.自定义组件中的behaviors

**1.什么是behaviors?**

behaviors是小程序中，<font color='red'>用于实现组件间代码共享</font>的特性，类似于Vue.js中的`mixins`

**2.behaviors的工作方式**

每个behaviors可以包含 一组==属性、数据、生命周期函数==和==方法==。组件引用它时，它的属性、数据和方法

<font color='red'>会被合并到组件中</font>。每个组件可以引用多个behavior,behavior也可以引用其它behavior。

**3.创建behavior**

调用<font color='red'>Behavior(object object)</font>方法即可创建一个<font color='red'>共享的behavior实例对象</font>，供所有的组件使用：

```js
// 调用Behavior() 方法，创建实例对象
// 并使用module.exports 将behavior 实例对象共享出去
module.exports = Behavior({
  // 属性节点
  properties:{},
  // 私有数据节点
  data: {username: 'zs'},
  // 事件处理函数和自定义方法节点
  methods:{},
  // 其它节点
})
```



**4.导入并且使用behavior**

在组件中，使用<font color='red'>require()</font>方法导出需要的behavior,<font color='red'>挂载后即可访问behavior中的数据或方法</font>,示例代码：

```js
// 1. 使用 require() 导入需要的自定义 behavior模块
const myBehavior = require("../../behaviors/my-behavior")
Component({
  // 2. 将导入的behavior实例对象，挂载到behaviors数组节点中，即可生效
  behaviors:[myBehavior]
})
```



**5.behavior中所有可用的节点**

|   可用的节点   |     类型     | 是否必填 |        描述        |
| :------------: | :----------: | :------: | :----------------: |
| ==properties== |  Object Map  |    否    |    同组件的属性    |
|    ==data==    |    Object    |    否    |    同组件的数据    |
|  ==methods==   |    Object    |    否    | 同自定义组件的方法 |
| ==behaviors==  | String Array |    否    |    生命周期函数    |
|    created     |   Function   |    否    |    生命周期函数    |
|    attached    |   Function   |    否    |    生命周期函数    |
|     ready      |   Function   |    否    |    生命周期函数    |
|     moved      |   Function   |    否    |    生命周期函数    |
|    detached    |   Function   |    否    |    生命周期函数    |

**6.同名字段的覆盖和组合规则**

组件和它引用的behavior中<font color='red'>可以包含同名的字段</font>, 此时可以参考如下3种同名时的处理规则：

- 同名的数据字段(data)
- 同名的属性(<font color='red'>properties</font>)或方法(<font color='red'>methods</font>)
- 同名的<font color='red'>生命周期函数</font>

关于详细的覆盖和组合规则，可以参考微信小程序官方文档说明：

`http://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html`



# 十七丶使用npm

**1.小程序对npm的支持与限制**

目前，小程序中已经支持使用npm安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用npm包有如下3个限制：

- 不支持依赖<font color='red'>Node.js内置库</font>的包
- 不支持依赖<font color='red'>浏览器内置对象</font>的包
- 不支持依赖于<font color='red'>C++插件</font>的包



# 十八丶Vant Weapp

**1.什么是Vant Weapp**, 它是一套开源的<font color='red'>小程序UI组件库</font>

官方文档地址: `https://youzan.github.io/vant-weapp`

**2.自定义主题样式**

```js
// 在app.wxss
page{
  --button-danger-background-color: #C00000;
  --button-danger-border-color: #D60000;
}
```



# 十九丶使用npm包- API Promise化

**1.基于回调函数的异步API的缺点**

默认情况下，小程序官方提供的异步<font color='red'>异步API</font>都是<font color='red'>基于回调函数</font>实现的，例如，网络请求API如下：

```js
wx.request({
  method: '',
  url: '',
  data: {},
  success: () => {}, // 请求成功的回调函数
  fail: () => {}, // 请求失败的回调函数
  complete: () => {} // 请求完成的回调函数
})
```

缺点：容易造成<font color='red'>回调地狱</font>的问题，代码的<font color='red'>可读性、维护性</font>差！

**2.什么是API Promise化**

==API Promise化==，指的是<font color='red'>通过额外的配置</font>,将官方提供的、基于回调函数的异步API，<font color='red'>升级改造为基于Promise的异步API</font>,从而提高代码的可读性、维护性，避免回调地狱的问题。

**3.实现Promise化**

需要依赖于<font color='red'>miniprogram-api-promise</font>第三方npm包

安装`npm install --save miniprogram-api-promise@1.0.4`

如何使用：

```js
// 在小程序入口文件中(app.js),只需要调用一次promisifyAll()方法
// 即可实现异步API的Promise化
import { promisifyAll } from 'miniprogram-api-promise'

const wxp = wx.p = {}

// promisity all wx's api
promisifyAll(wx, wxp)

```



**4.调用Promise化后的异步API**

```js
// home.js

async getInfo() {
    const { data } = await wx.p.request({
      method: 'GET',
      url: 'https://www.escook.cn/api/get',
      data: {
        name: 'zs',
        age: 20
      }
    })
    console.log(data)
  },
```





# 二十丶全局数据共享

**1.什么是全局数据共享**

<font color='red'>全局数据共享</font>又叫做状态管理)是为了解决<font color='red'>组件之间数据共享</font>的问题。

在小程序中，可以使用<font color='red'>mobx-miniprogram</font>配合<font color='red'>mobx-miniprogram-bindings</font>来实现全局数据共享:

- mobx-miniprogram用来<font color='red'>创建Store实例对象</font>
- mobx-miniprogram-bindings用来<font color='red'>把Store中的共享数据或方法，绑定到组件或页面中使用</font>

**2.安装MobX相关的包**

`npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1`



**3.创建MobX实例**

项目根目录创建store文件夹，并且在store文件夹下创建store.js文件

```js
// 在这个js文件中专门创建store实例对象
import { observable } from 'mobx-miniprogram'
export const store = observable({
  // 数据字段
  numA: 1,
  numB: 2,
    
  // 计算属性
  get sum(){
    return this.numA + this.numB  
  },
  // action 方法，用来修改store里的数据
  updateNum1: action(function(step){
    this.numA += step
  }),
  updateNum2: action(function(step){
    this.numB += step
  })
})
```



**4.将Store中的成员**<font color='red'>绑定到页面中</font>

```js
// message.js中

onLoad() {
    this.storeBindings = createStoreBindings(this, {
      store,
      fields: ['numA', 'numB', 'sum'],
      actions: ['updateNum1', 'updateNum2']
    })
    console.log(this.storeBindings)
  },
  
   onUnload() {
    this.storeBindings.destoryStoreBindings()
  },
```



5.将Store中的成员中<font color='red'>绑定到组件中</font>

```js
// components/numbers/numbers.js
import {
  storeBindingsBehavior
} from 'mobx-miniprogram-bindings'
import {
  store
} from '../../store/store'
Component({
  behaviors: [storeBindingsBehavior], // 通过storeBindingsBehavior来实现自动绑定
  storeBindings: {
    store, // 指定要绑定的Store
    fields: { // 指定要绑定的字段数据
      numA: () => store.numA, // 绑定字段的第1种方式
      numB: (store) => store.numB, // 绑定字段的第2种方式
      sum: 'sum' // 绑定字段的第3种方式
    },
    actions: {
      updateNum2: 'updateNum2'
    }
  },
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {

  }
})
```



# 二十一丶分包

**1.什么是分包**

分包是指把一个<font color='red'>完整的小程序项目</font>, 按需求划分为不同的子包, 在构建时打包成不同的分包，用户在使用时<font color='red'>按需进行加载</font>

**2.分包的好处**

- 可以<font color='red'>优化小程序首次启动的下载时间</font>
- 在<font color='red'>多团队共同开发</font>时更改的<font color='red'>解耦协作</font>

**3.<font color='red'>分包前</font>项目的构成**

分包前，小程序项目中<font color='red'>所有的页面和资源</font>都被打包了一起，导致整个<font color='red'>项目体积过大</font>,影响小程序<font color='red'>首次启动的下载时间</font>

**4.<font color='red'>分包后</font>项目的构成**

分包后，小程序项目由<font color='red'>1个主包和多个分包</font>组成：

- 主包：一般只包含项目的<font color='red'>启动页面</font>或<font color='red'>TabBar页面</font>、以及所有分包都需要用到的一些<font color='red'>公共资源</font>
- 分包： 只包含和当前分包有关的页面和私有资源

**5.分包的加载规则**

1.在小程序启动时，默认会**下载主包并启动主包内页面**

- tabBar页面需要放到主包中



2.当用户进入分包内某个页面是，<font color='red'>客户端会把对应的分包下载下来</font>，下载完成后再进行展示

- 非tabBar页面可以按照功能的不同，划分为不同的分包之后，进行按需加载

​		

**6.分包的体积限制**

目前，小程序分包的大小有以下两个限制：

- 整个小程序所有分包大小不超过<font color='red'>16M</font>(主包 + 所有分包)
- 单个分包/主包大小不能超过<font color='red'>2M</font>



**7.配置方法**

![image-20230522172302340](C:/Users/hyf/Desktop/Typora%E7%AC%94%E8%AE%B0/images/image-20230522172302340.png)
